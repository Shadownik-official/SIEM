import nmap
import socket
import requests
import threading
import queue
import logging
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import json
import subprocess
import platform
from pathlib import Path
import yaml
import re
from dataclasses import dataclass
import xml.etree.ElementTree as ET

@dataclass
class Vulnerability:
    """Represents a detected vulnerability."""
    id: str
    name: str
    description: str
    severity: str
    cvss_score: float
    affected_component: str
    remediation_steps: List[str]
    references: List[str]

class VulnerabilityScanner:
    """Advanced vulnerability scanning and assessment engine."""
    
    def __init__(self, config_path: str = None):
        self.logger = logging.getLogger(__name__)
        self.config = self._load_config(config_path)
        self.scan_queue = queue.Queue()
        self.stop_flag = threading.Event()
        self.nm = nmap.PortScanner()
        self.vulnerabilities = {}
        self._load_vulnerability_database()
        
    def _load_config(self, config_path: Optional[str]) -> Dict:
        """Load configuration settings."""
        default_config = {
            "scan_types": ["port", "service", "vulnerability", "web"],
            "port_ranges": "1-1024,1433,3306,3389,5432,27017",
            "concurrent_scans": 5,
            "timeout": 300,  # seconds
            "web_scan": {
                "crawl_depth": 3,
                "exclude_paths": [],
                "auth": {
                    "enabled": False,
                    "method": "basic",
                    "credentials": {}
                }
            },
            "reporting": {
                "min_severity": "medium",
                "formats": ["json", "html", "pdf"]
            }
        }
        
        if config_path:
            try:
                with open(config_path, 'r') as f:
                    return {**default_config, **yaml.safe_load(f)}
            except Exception as e:
                self.logger.warning(f"Error loading config: {str(e)}. Using defaults.")
                return default_config
        return default_config
        
    def _load_vulnerability_database(self):
        """Load vulnerability definitions from various sources."""
        try:
            # Load from local database
            db_path = Path(__file__).parent / "data" / "vulnerabilities.json"
            if db_path.exists():
                with open(db_path, 'r') as f:
                    self.vulnerabilities = json.load(f)
                    
            # Update from online sources (NVD, ExploitDB, etc.)
            self._update_vulnerability_database()
            
        except Exception as e:
            self.logger.error(f"Error loading vulnerability database: {str(e)}")
            
    def _update_vulnerability_database(self):
        """Update vulnerability database from online sources."""
        try:
            # Update from National Vulnerability Database (NVD)
            nvd_api_url = "https://services.nvd.nist.gov/rest/json/cves/1.0"
            response = requests.get(nvd_api_url)
            if response.status_code == 200:
                data = response.json()
                # Process and store vulnerability data
                self._process_nvd_data(data)
                
        except Exception as e:
            self.logger.error(f"Error updating vulnerability database: {str(e)}")
            
    def start_scanning(self, targets: List[str]):
        """Start vulnerability scanning for specified targets."""
        try:
            # Validate targets
            valid_targets = self._validate_targets(targets)
            
            # Initialize scan threads
            for _ in range(self.config['concurrent_scans']):
                thread = threading.Thread(target=self._scan_worker)
                thread.start()
                
            # Add targets to scan queue
            for target in valid_targets:
                self.scan_queue.put(target)
                
            self.logger.info(f"Started scanning {len(valid_targets)} targets")
            
        except Exception as e:
            self.logger.error(f"Error starting scan: {str(e)}")
            raise
            
    def stop_scanning(self):
        """Stop all scanning operations."""
        self.stop_flag.set()
        self.logger.info("Scanning operations stopped")
        
    def _validate_targets(self, targets: List[str]) -> List[str]:
        """Validate and normalize target specifications."""
        valid_targets = []
        for target in targets:
            try:
                # Check if IP address
                socket.inet_aton(target)
                valid_targets.append(target)
            except socket.error:
                # Check if hostname
                try:
                    ip = socket.gethostbyname(target)
                    valid_targets.append(ip)
                except socket.gaierror:
                    self.logger.warning(f"Invalid target: {target}")
                    
        return valid_targets
        
    def _scan_worker(self):
        """Worker thread for scanning targets."""
        while not self.stop_flag.is_set():
            try:
                target = self.scan_queue.get(timeout=1)
                self._scan_target(target)
                
            except queue.Empty:
                continue
            except Exception as e:
                self.logger.error(f"Error in scan worker: {str(e)}")
                
    def _scan_target(self, target: str):
        """Perform comprehensive scan of a target."""
        try:
            results = {
                'target': target,
                'timestamp': datetime.now().isoformat(),
                'scans': {}
            }
            
            # Port scan
            if 'port' in self.config['scan_types']:
                results['scans']['ports'] = self._port_scan(target)
                
            # Service detection
            if 'service' in self.config['scan_types']:
                results['scans']['services'] = self._service_scan(target)
                
            # Vulnerability scan
            if 'vulnerability' in self.config['scan_types']:
                results['scans']['vulnerabilities'] = \
                    self._vulnerability_scan(target)
                
            # Web application scan
            if 'web' in self.config['scan_types']:
                results['scans']['web'] = self._web_scan(target)
                
            # Process and store results
            self._process_scan_results(results)
            
        except Exception as e:
            self.logger.error(f"Error scanning target {target}: {str(e)}")
            
    def _port_scan(self, target: str) -> Dict:
        """Perform port scan using nmap."""
        try:
            # Run nmap scan
            self.nm.scan(
                target,
                arguments=f"-p{self.config['port_ranges']} -sS -T4"
            )
            
            return {
                'open_ports': self._parse_nmap_ports(self.nm[target])
            }
            
        except Exception as e:
            self.logger.error(f"Error in port scan: {str(e)}")
            return {'error': str(e)}
            
    def _service_scan(self, target: str) -> Dict:
        """Perform service detection scan."""
        try:
            # Run nmap service detection
            self.nm.scan(
                target,
                arguments="-sV -sC -O --version-intensity 5"
            )
            
            return {
                'services': self._parse_nmap_services(self.nm[target]),
                'os_detection': self._parse_nmap_os(self.nm[target])
            }
            
        except Exception as e:
            self.logger.error(f"Error in service scan: {str(e)}")
            return {'error': str(e)}
            
    def _vulnerability_scan(self, target: str) -> Dict:
        """Perform vulnerability scan."""
        try:
            vulnerabilities = []
            
            # Run nmap NSE scripts
            self.nm.scan(
                target,
                arguments="--script vuln"
            )
            
            # Parse NSE results
            vulns = self._parse_nmap_vulnerabilities(self.nm[target])
            vulnerabilities.extend(vulns)
            
            # Additional vulnerability checks
            custom_vulns = self._custom_vulnerability_checks(target)
            vulnerabilities.extend(custom_vulns)
            
            return {
                'vulnerabilities': vulnerabilities,
                'total_count': len(vulnerabilities),
                'severity_counts': self._count_vulnerabilities_by_severity(
                    vulnerabilities)
            }
            
        except Exception as e:
            self.logger.error(f"Error in vulnerability scan: {str(e)}")
            return {'error': str(e)}
            
    def _web_scan(self, target: str) -> Dict:
        """Perform web application security scan."""
        try:
            results = {
                'endpoints': [],
                'vulnerabilities': [],
                'technologies': []
            }
            
            # Discover web endpoints
            endpoints = self._discover_web_endpoints(target)
            results['endpoints'] = endpoints
            
            # Scan each endpoint
            for endpoint in endpoints:
                # Check common web vulnerabilities
                vulns = self._check_web_vulnerabilities(endpoint)
                results['vulnerabilities'].extend(vulns)
                
                # Detect technologies
                techs = self._detect_web_technologies(endpoint)
                results['technologies'].extend(techs)
                
            return results
            
        except Exception as e:
            self.logger.error(f"Error in web scan: {str(e)}")
            return {'error': str(e)}
            
    def _discover_web_endpoints(self, target: str) -> List[str]:
        """Discover web endpoints through crawling."""
        discovered = set()
        try:
            base_url = f"http://{target}"
            to_visit = queue.Queue()
            to_visit.put(base_url)
            
            depth = self.config['web_scan']['crawl_depth']
            while depth > 0 and not to_visit.empty():
                url = to_visit.get()
                
                try:
                    response = requests.get(
                        url,
                        timeout=self.config['timeout'],
                        verify=False
                    )
                    
                    # Extract links
                    links = re.findall(
                        r'href=[\'"]?([^\'" >]+)',
                        response.text
                    )
                    
                    for link in links:
                        if link not in discovered:
                            discovered.add(link)
                            to_visit.put(link)
                            
                except requests.RequestException:
                    continue
                    
                depth -= 1
                
            return list(discovered)
            
        except Exception as e:
            self.logger.error(f"Error discovering endpoints: {str(e)}")
            return []
            
    def _check_web_vulnerabilities(self, url: str) -> List[Dict]:
        """Check for common web vulnerabilities."""
        vulnerabilities = []
        try:
            # Check for SQL injection
            sql_vulns = self._check_sql_injection(url)
            vulnerabilities.extend(sql_vulns)
            
            # Check for XSS
            xss_vulns = self._check_xss(url)
            vulnerabilities.extend(xss_vulns)
            
            # Check for CSRF
            csrf_vulns = self._check_csrf(url)
            vulnerabilities.extend(csrf_vulns)
            
            return vulnerabilities
            
        except Exception as e:
            self.logger.error(f"Error checking web vulnerabilities: {str(e)}")
            return []
            
    def _detect_web_technologies(self, url: str) -> List[str]:
        """Detect web technologies and frameworks."""
        technologies = set()
        try:
            response = requests.get(url, timeout=self.config['timeout'])
            
            # Check headers
            headers = response.headers
            server = headers.get('Server')
            if server:
                technologies.add(f"Server: {server}")
                
            # Check for common frameworks
            content = response.text.lower()
            if 'django' in content:
                technologies.add('Django')
            if 'laravel' in content:
                technologies.add('Laravel')
            if 'react' in content:
                technologies.add('React')
            
            return list(technologies)
            
        except Exception as e:
            self.logger.error(f"Error detecting technologies: {str(e)}")
            return []
            
    def _process_scan_results(self, results: Dict):
        """Process and store scan results."""
        try:
            # Store results
            output_dir = Path("scan_results")
            output_dir.mkdir(exist_ok=True)
            
            # Save raw results
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = output_dir / f"scan_{results['target']}_{timestamp}.json"
            
            with open(output_file, 'w') as f:
                json.dump(results, f, indent=4)
                
            # Generate reports
            self._generate_reports(results)
            
        except Exception as e:
            self.logger.error(f"Error processing results: {str(e)}")
            
    def _generate_reports(self, results: Dict):
        """Generate scan reports in various formats."""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            base_name = f"scan_report_{results['target']}_{timestamp}"
            
            if 'json' in self.config['reporting']['formats']:
                self._generate_json_report(results, f"{base_name}.json")
                
            if 'html' in self.config['reporting']['formats']:
                self._generate_html_report(results, f"{base_name}.html")
                
            if 'pdf' in self.config['reporting']['formats']:
                self._generate_pdf_report(results, f"{base_name}.pdf")
                
        except Exception as e:
            self.logger.error(f"Error generating reports: {str(e)}")
            
    def get_scan_status(self, target: str) -> Dict:
        """Get current scan status for a target."""
        try:
            # Implementation depends on how you track scan progress
            return {
                'target': target,
                'status': 'unknown'
            }
        except Exception as e:
            self.logger.error(f"Error getting scan status: {str(e)}")
            return {'error': str(e)}
            
    def get_vulnerability_details(self, vuln_id: str) -> Optional[Dict]:
        """Get detailed information about a vulnerability."""
        try:
            return self.vulnerabilities.get(vuln_id)
        except Exception as e:
            self.logger.error(f"Error getting vulnerability details: {str(e)}")
            return None
            
    def scan_containers(self, containers: List[str]) -> Dict:
        """Scan containers for vulnerabilities."""
        try:
            results = {}
            for container in containers:
                container_results = {
                    'base_image_vulns': self._scan_base_image(container),
                    'dependency_vulns': self._scan_dependencies(container),
                    'config_issues': self._check_container_config(container),
                    'runtime_vulns': self._scan_runtime(container),
                    'compliance': self._check_container_compliance(container)
                }
                results[container] = container_results
                
            return results
            
        except Exception as e:
            self.logger.error(f"Error scanning containers: {str(e)}")
            return {'error': str(e)}
            
    def _scan_base_image(self, container: str) -> Dict:
        """Scan container base image for vulnerabilities."""
        try:
            # Use Trivy for base image scanning
            cmd = ['trivy', 'image', '--format', 'json', container]
            result = subprocess.run(cmd, capture_output=True, text=True)
            return json.loads(result.stdout)
            
        except Exception as e:
            self.logger.error(f"Error scanning base image: {str(e)}")
            return {'error': str(e)}
            
    def _scan_dependencies(self, container: str) -> Dict:
        """Scan container dependencies for vulnerabilities."""
        try:
            results = {
                'python': self._scan_python_deps(container),
                'node': self._scan_node_deps(container),
                'java': self._scan_java_deps(container)
            }
            return results
            
        except Exception as e:
            self.logger.error(f"Error scanning dependencies: {str(e)}")
            return {'error': str(e)}
            
    def _check_container_config(self, container: str) -> Dict:
        """Check container configuration for security issues."""
        try:
            issues = []
            
            # Check for common misconfigurations
            cmd = ['docker', 'inspect', container]
            result = subprocess.run(cmd, capture_output=True, text=True)
            config = json.loads(result.stdout)[0]
            
            # Check privileged mode
            if config.get('HostConfig', {}).get('Privileged'):
                issues.append({
                    'type': 'privileged_mode',
                    'severity': 'high',
                    'description': 'Container running in privileged mode'
                })
                
            # Check root user
            if not config.get('Config', {}).get('User'):
                issues.append({
                    'type': 'root_user',
                    'severity': 'medium',
                    'description': 'Container running as root user'
                })
                
            return {'issues': issues}
            
        except Exception as e:
            self.logger.error(f"Error checking container config: {str(e)}")
            return {'error': str(e)}
            
    def _scan_runtime(self, container: str) -> Dict:
        """Scan container runtime for vulnerabilities."""
        try:
            # Use Falco for runtime security monitoring
            cmd = ['falco', '--container', container, '--json-output']
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            results = []
            while True:
                output = process.stdout.readline()
                if not output and process.poll() is not None:
                    break
                if output:
                    results.append(json.loads(output))
                    
            return {'runtime_alerts': results}
            
        except Exception as e:
            self.logger.error(f"Error scanning runtime: {str(e)}")
            return {'error': str(e)}
            
    def _check_container_compliance(self, container: str) -> Dict:
        """Check container compliance with security standards."""
        try:
            # Use Docker Bench Security
            cmd = ['docker-bench-security', '--container', container, '--json']
            result = subprocess.run(cmd, capture_output=True, text=True)
            return json.loads(result.stdout)
            
        except Exception as e:
            self.logger.error(f"Error checking compliance: {str(e)}")
            return {'error': str(e)}
            
    def check_compliance(self, target: str, standards: List[str]) -> Dict:
        """Check compliance with security standards."""
        try:
            results = {}
            for standard in standards:
                if standard.upper() == 'PCI-DSS':
                    results['PCI-DSS'] = self._check_pci_dss_compliance(target)
                elif standard.upper() == 'HIPAA':
                    results['HIPAA'] = self._check_hipaa_compliance(target)
                elif standard.upper() == 'ISO27001':
                    results['ISO27001'] = self._check_iso27001_compliance(target)
                elif standard.upper() == 'GDPR':
                    results['GDPR'] = self._check_gdpr_compliance(target)
                    
            return results
            
        except Exception as e:
            self.logger.error(f"Error checking compliance: {str(e)}")
            return {'error': str(e)}
            
    def _check_pci_dss_compliance(self, target: str) -> Dict:
        """Check PCI-DSS compliance requirements."""
        try:
            requirements = {
                'req_1': self._check_firewall_requirements(target),
                'req_2': self._check_secure_configs(target),
                'req_3': self._check_data_protection(target),
                'req_4': self._check_transmission_encryption(target),
                'req_5': self._check_antivirus(target),
                'req_6': self._check_secure_systems(target)
            }
            return requirements
            
        except Exception as e:
            self.logger.error(f"Error checking PCI-DSS compliance: {str(e)}")
            return {'error': str(e)}
            
    def get_remediation_plan(self, scan_results: Dict) -> Dict:
        """Generate detailed remediation plan for vulnerabilities."""
        try:
            plan = {
                'critical': [],
                'high': [],
                'medium': [],
                'low': []
            }
            
            # Process vulnerabilities by severity
            for vuln in scan_results.get('vulnerabilities', []):
                remediation = {
                    'vulnerability': vuln['name'],
                    'description': vuln['description'],
                    'steps': self._generate_remediation_steps(vuln),
                    'resources': self._find_remediation_resources(vuln),
                    'estimated_effort': self._estimate_remediation_effort(vuln)
                }
                plan[vuln['severity']].append(remediation)
                
            return plan
            
        except Exception as e:
            self.logger.error(f"Error generating remediation plan: {str(e)}")
            return {'error': str(e)}
            
    def _generate_remediation_steps(self, vulnerability: Dict) -> List[str]:
        """Generate specific steps for vulnerability remediation."""
        try:
            # Get base remediation steps
            steps = vulnerability.get('remediation_steps', [])
            
            # Add context-specific steps
            if vulnerability.get('type') == 'outdated_software':
                steps.extend([
                    f"Update {vulnerability['affected_component']} to latest version",
                    "Test system compatibility after update",
                    "Deploy update in staging environment first"
                ])
            elif vulnerability.get('type') == 'misconfiguration':
                steps.extend([
                    "Review configuration against security baseline",
                    "Apply security hardening guidelines",
                    "Validate changes don't impact functionality"
                ])
                
            return steps
            
        except Exception as e:
            self.logger.error(f"Error generating remediation steps: {str(e)}")
            return []
            
    def _find_remediation_resources(self, vulnerability: Dict) -> List[Dict]:
        """Find relevant resources for vulnerability remediation."""
        try:
            resources = []
            
            # Check official documentation
            if vulnerability.get('references'):
                resources.extend([
                    {'type': 'reference', 'url': ref}
                    for ref in vulnerability['references']
                ])
                
            # Check security advisories
            advisory_url = f"https://nvd.nist.gov/vuln/detail/{vulnerability['id']}"
            resources.append({
                'type': 'advisory',
                'url': advisory_url
            })
            
            # Check for patches
            if vulnerability.get('patch_available'):
                resources.append({
                    'type': 'patch',
                    'url': vulnerability['patch_url']
                })
                
            return resources
            
        except Exception as e:
            self.logger.error(f"Error finding remediation resources: {str(e)}")
            return []
            
    def _estimate_remediation_effort(self, vulnerability: Dict) -> Dict:
        """Estimate effort required for vulnerability remediation."""
        try:
            effort = {
                'complexity': 'medium',
                'estimated_time': '2-4 hours',
                'required_skills': ['system_administration'],
                'potential_impacts': []
            }
            
            # Adjust based on vulnerability type
            if vulnerability.get('type') == 'outdated_software':
                effort.update({
                    'complexity': 'low',
                    'estimated_time': '1-2 hours',
                    'required_skills': ['system_administration'],
                    'potential_impacts': ['service_restart_required']
                })
            elif vulnerability.get('type') == 'misconfiguration':
                effort.update({
                    'complexity': 'medium',
                    'estimated_time': '2-4 hours',
                    'required_skills': ['system_administration', 'security'],
                    'potential_impacts': ['config_changes_required']
                })
                
            return effort
            
        except Exception as e:
            self.logger.error(f"Error estimating remediation effort: {str(e)}")
            return {}
            
    def integrate_threat_intelligence(self):
        """Integrate with threat intelligence feeds."""
        try:
            feeds = {
                'mitre': self._fetch_mitre_data(),
                'alienvault': self._fetch_alienvault_data(),
                'virustotal': self._fetch_virustotal_data()
            }
            
            # Update vulnerability database with threat intel
            self._update_vuln_database_with_threat_intel(feeds)
            
            return {'status': 'success', 'feeds_integrated': list(feeds.keys())}
            
        except Exception as e:
            self.logger.error(f"Error integrating threat intelligence: {str(e)}")
            return {'error': str(e)}
