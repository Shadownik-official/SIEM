import subprocess
import threading
import tempfile
import os
from typing import Dict, List, Optional
import logging
import json
from pathlib import Path
import requests
import time
from dataclasses import dataclass
import xml.etree.ElementTree as ET

@dataclass
class ExploitTarget:
    host: str
    port: int
    service: str
    vulnerability: str
    exploit_module: str
    payload: str
    options: Dict
    success_probability: float
    risk_level: str

class ExploitationFramework:
    def __init__(self, msf_path: str = None):
        self.logger = logging.getLogger(__name__)
        self.msf_path = msf_path or self._find_metasploit()
        self.exploits_db = self._load_exploit_database()
        self.current_session = None
        
    def scan_target(self, target: str, ports: str = None) -> Dict:
        """Scan target for vulnerabilities and potential exploits"""
        try:
            # Run initial Nmap scan
            scan_results = self._run_nmap_scan(target, ports)
            
            # Analyze results and find potential exploits
            vulnerabilities = self._analyze_vulnerabilities(scan_results)
            
            # Match vulnerabilities with available exploits
            exploit_matches = self._match_exploits(vulnerabilities)
            
            # Generate report
            report = {
                "target": target,
                "timestamp": time.time(),
                "vulnerabilities": vulnerabilities,
                "potential_exploits": exploit_matches,
                "risk_assessment": self._assess_risk(vulnerabilities),
                "recommendations": self._generate_recommendations(vulnerabilities)
            }
            
            return report
            
        except Exception as e:
            self.logger.error(f"Error scanning target {target}: {str(e)}")
            raise
            
    def prepare_exploit(self, target: ExploitTarget) -> Dict:
        """Prepare an exploit for execution"""
        try:
            # Validate exploit module
            if not self._validate_exploit(target.exploit_module):
                raise ValueError(f"Invalid exploit module: {target.exploit_module}")
                
            # Check if exploit is safe to use
            risk_assessment = self._assess_exploit_risk(target)
            if risk_assessment["risk_level"] == "critical":
                raise ValueError("Exploit risk level too high")
                
            # Prepare exploit configuration
            config = self._prepare_exploit_config(target)
            
            # Generate resource script
            resource_script = self._generate_resource_script(config)
            
            return {
                "config": config,
                "resource_script": resource_script,
                "risk_assessment": risk_assessment,
                "estimated_success": target.success_probability
            }
            
        except Exception as e:
            self.logger.error(f"Error preparing exploit: {str(e)}")
            raise
            
    def _find_metasploit(self) -> str:
        """Find Metasploit installation path"""
        common_paths = [
            "/opt/metasploit-framework",
            "C:\\Metasploit",
            "/usr/share/metasploit-framework"
        ]
        
        for path in common_paths:
            if os.path.exists(path):
                return path
                
        raise FileNotFoundError("Metasploit framework not found")
        
    def _load_exploit_database(self) -> Dict:
        """Load exploit database with success rates and risk levels"""
        try:
            db_path = Path(__file__).parent / "data" / "exploit_db.json"
            with open(db_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Error loading exploit database: {str(e)}")
            return {}
            
    def _run_nmap_scan(self, target: str, ports: Optional[str]) -> Dict:
        """Run Nmap scan with NSE scripts"""
        try:
            # Prepare Nmap command
            cmd = [
                "nmap",
                "-sV",  # Version detection
                "-sC",  # Default scripts
                "--script=vuln",  # Vulnerability scripts
                "-oX", "-"  # Output in XML format to stdout
            ]
            
            if ports:
                cmd.extend(["-p", ports])
                
            cmd.append(target)
            
            # Run scan
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            # Parse XML output
            return self._parse_nmap_output(result.stdout)
            
        except Exception as e:
            self.logger.error(f"Error running Nmap scan: {str(e)}")
            raise
            
    def _analyze_vulnerabilities(self, scan_results: Dict) -> List[Dict]:
        """Analyze scan results for vulnerabilities"""
        vulnerabilities = []
        
        try:
            for host in scan_results.get("hosts", []):
                for port in host.get("ports", []):
                    service = port.get("service", {})
                    scripts = port.get("scripts", [])
                    
                    for script in scripts:
                        if "VULNERABLE" in script.get("output", ""):
                            vuln = {
                                "host": host["addr"],
                                "port": port["portid"],
                                "service": service.get("name"),
                                "vulnerability": script["id"],
                                "details": script["output"],
                                "severity": self._determine_severity(script)
                            }
                            vulnerabilities.append(vuln)
                            
            return vulnerabilities
            
        except Exception as e:
            self.logger.error(f"Error analyzing vulnerabilities: {str(e)}")
            raise
            
    def _match_exploits(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Match vulnerabilities with available exploits"""
        matches = []
        
        for vuln in vulnerabilities:
            exploit_matches = self._find_matching_exploits(vuln)
            if exploit_matches:
                matches.extend([
                    {
                        "vulnerability": vuln,
                        "exploit": exploit,
                        "success_probability": self._calculate_success_probability(
                            vuln, exploit
                        ),
                        "risk_level": self._calculate_risk_level(vuln, exploit)
                    }
                    for exploit in exploit_matches
                ])
                
        return matches
        
    def _assess_exploit_risk(self, target: ExploitTarget) -> Dict:
        """Assess the risk of using an exploit"""
        risk_factors = []
        risk_level = "low"
        
        # Check exploit stability
        if target.success_probability < 0.7:
            risk_factors.append("Low success probability")
            risk_level = "medium"
            
        # Check for potential system damage
        if "critical" in target.service.lower():
            risk_factors.append("Critical system service")
            risk_level = "high"
            
        # Check for data loss risk
        if any(kw in target.exploit_module.lower() 
               for kw in ["delete", "wipe", "format"]):
            risk_factors.append("Potential data loss")
            risk_level = "critical"
            
        return {
            "risk_level": risk_level,
            "risk_factors": risk_factors,
            "mitigations": self._suggest_risk_mitigations(risk_factors)
        }
        
    def _suggest_risk_mitigations(self, risk_factors: List[str]) -> List[str]:
        """Suggest mitigations for identified risks"""
        mitigations = []
        
        if "Low success probability" in risk_factors:
            mitigations.extend([
                "Test exploit in a controlled environment first",
                "Prepare backup exploitation method",
                "Monitor target system closely during execution"
            ])
            
        if "Critical system service" in risk_factors:
            mitigations.extend([
                "Schedule exploitation during maintenance window",
                "Prepare service recovery procedures",
                "Have system backup ready"
            ])
            
        if "Potential data loss" in risk_factors:
            mitigations.extend([
                "Create full system backup",
                "Document current configuration",
                "Prepare rollback procedure"
            ])
            
        return mitigations
        
    def _generate_resource_script(self, config: Dict) -> str:
        """Generate Metasploit resource script"""
        script_lines = [
            "# Auto-generated resource script",
            f"use {config['module']}",
            "",
            "# Set exploit options"
        ]
        
        # Add options
        for key, value in config["options"].items():
            script_lines.append(f"set {key} {value}")
            
        # Add execution commands
        script_lines.extend([
            "",
            "# Execute exploit",
            "check",
            "exploit -j"
        ])
        
        return "\n".join(script_lines)
        
    def _validate_exploit(self, module: str) -> bool:
        """Validate if exploit module exists and is usable"""
        try:
            cmd = [
                os.path.join(self.msf_path, "msfconsole"),
                "-q",  # Quiet mode
                "-x", f"use {module}; exit"
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)
            return "No such module" not in result.stderr
        except Exception as e:
            self.logger.error(f"Error validating exploit module: {str(e)}")
            return False
